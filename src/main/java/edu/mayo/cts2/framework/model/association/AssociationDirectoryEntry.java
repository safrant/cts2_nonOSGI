/*
 * This class was automatically generated with 
 * <a href="http://www.castor.org">Castor 1.3.1</a>, using an XML
 * Schema.
 * $Id$
 */

package edu.mayo.cts2.framework.model.association;

import edu.mayo.cts2.framework.model.association.types.AssociationDerivation;
import edu.mayo.cts2.framework.model.core.CodeSystemVersionReference;
import edu.mayo.cts2.framework.model.core.DirectoryEntry;
import edu.mayo.cts2.framework.model.core.PredicateReference;
import edu.mayo.cts2.framework.model.core.StatementTarget;
import edu.mayo.cts2.framework.model.core.URIAndEntityName;

/**
 * A synopsis of an Association along with information about how to
 * access the complete resource.
 * 
 * @version $Revision$ $Date$
 */
@SuppressWarnings("serial")
public class AssociationDirectoryEntry extends DirectoryEntry
implements java.io.Serializable
{


      //--------------------------/
     //- Class/Member Variables -/
    //--------------------------/

    /**
     * the unique identifier of the association instance. While the
     * update mechanism of the CTS2 specifications requires that
     * all Changeable elements have unique identifiers, the rules
     *  and mechanism for assigning unique identifiers to
     * statements and associations are non-trivial. At the moment,
     * the CTS2 specification remains silent when it comes to
     * arriving at how this identifier is
     *  generated except to note that, if two service
     * implementations do not generate the same unique identifier
     * for the same assertion, then the prevImage element in
     * Changeable becomes the only way to
     *  identify which Association instance is being updated or
     * deleted.
     */
    private String _associationID;

    /**
     * the local identifier of the association instance. If
     * externalStatementID is present, it will be used
     *  for the localId. If not, the localID will be generated by
     * the service.
     */
    private String _localID;

    /**
     * how this association was derived. ASSERTED takes precedence
     * over DERIVED , meaning that an assertion that is both
     * asserted and derived is marked as asserted.
     */
    private AssociationDerivation _derivation;

    /**
     * the subject of the association statement
     */
    private URIAndEntityName _subject;

    /**
     * the predicate of the association statement
     */
    private PredicateReference _predicate;

    /**
     * the target (object) of the association statement
     */
    private StatementTarget _target;

    /**
     * the code system version that is making this assertion
     */
    private CodeSystemVersionReference _assertedBy;


      //----------------/
     //- Constructors -/
    //----------------/

    public AssociationDirectoryEntry() {
        super();
    }


      //-----------/
     //- Methods -/
    //-----------/

    /**
     * Overrides the java.lang.Object.equals method.
     * 
     * @param obj
     * @return true if the objects are equal.
     */
    @Override()
    public boolean equals(
            final Object obj) {
        if ( this == obj )
            return true;

        if (!super.equals(obj))
            return false;

        if (obj instanceof AssociationDirectoryEntry) {

            AssociationDirectoryEntry temp = (AssociationDirectoryEntry)obj;
            if (this._associationID != null) {
                if (temp._associationID == null) return false;
                if (!this._associationID.equals(temp._associationID)) 
                    return false;
            } else if (temp._associationID != null)
                return false;
            if (this._localID != null) {
                if (temp._localID == null) return false;
                if (!this._localID.equals(temp._localID)) 
                    return false;
            } else if (temp._localID != null)
                return false;
            if (this._derivation != null) {
                if (temp._derivation == null) return false;
                if (!this._derivation.equals(temp._derivation)) 
                    return false;
            } else if (temp._derivation != null)
                return false;
            if (this._subject != null) {
                if (temp._subject == null) return false;
                if (!this._subject.equals(temp._subject)) 
                    return false;
            } else if (temp._subject != null)
                return false;
            if (this._predicate != null) {
                if (temp._predicate == null) return false;
                if (!this._predicate.equals(temp._predicate)) 
                    return false;
            } else if (temp._predicate != null)
                return false;
            if (this._target != null) {
                if (temp._target == null) return false;
                if (!this._target.equals(temp._target)) 
                    return false;
            } else if (temp._target != null)
                return false;
            if (this._assertedBy != null) {
                if (temp._assertedBy == null) return false;
                return this._assertedBy.equals(temp._assertedBy);
            } else return temp._assertedBy == null;
        }
        return false;
    }

    /**
     * Returns the value of field 'assertedBy'. The field
     * 'assertedBy' has the following description: the code system
     * version that is making this assertion
     * 
     * @return the value of field 'AssertedBy'.
     */
    public CodeSystemVersionReference getAssertedBy(
    ) {
        return this._assertedBy;
    }

    /**
     * Returns the value of field 'associationID'. The field
     * 'associationID' has the following description: the unique
     * identifier of the association instance. While the update
     * mechanism of the CTS2 specifications requires that all
     * Changeable elements have unique identifiers, the rules
     *  and mechanism for assigning unique identifiers to
     * statements and associations are non-trivial. At the moment,
     * the CTS2 specification remains silent when it comes to
     * arriving at how this identifier is
     *  generated except to note that, if two service
     * implementations do not generate the same unique identifier
     * for the same assertion, then the prevImage element in
     * Changeable becomes the only way to
     *  identify which Association instance is being updated or
     * deleted.
     * 
     * @return the value of field 'AssociationID'.
     */
    public String getAssociationID(
    ) {
        return this._associationID;
    }

    /**
     * Returns the value of field 'derivation'. The field
     * 'derivation' has the following description: how this
     * association was derived. ASSERTED takes precedence over
     * DERIVED , meaning that an assertion that is both asserted
     * and derived is marked as asserted.
     * 
     * @return the value of field 'Derivation'.
     */
    public AssociationDerivation getDerivation(
    ) {
        return this._derivation;
    }

    /**
     * Returns the value of field 'localID'. The field 'localID'
     * has the following description: the local identifier of the
     * association instance. If externalStatementID is present, it
     * will be used
     *  for the localId. If not, the localID will be generated by
     * the service.
     * 
     * @return the value of field 'LocalID'.
     */
    public String getLocalID(
    ) {
        return this._localID;
    }

    /**
     * Returns the value of field 'predicate'. The field
     * 'predicate' has the following description: the predicate of
     * the association statement
     * 
     * @return the value of field 'Predicate'.
     */
    public PredicateReference getPredicate(
    ) {
        return this._predicate;
    }

    /**
     * Returns the value of field 'subject'. The field 'subject'
     * has the following description: the subject of the
     * association statement
     * 
     * @return the value of field 'Subject'.
     */
    public URIAndEntityName getSubject(
    ) {
        return this._subject;
    }

    /**
     * Returns the value of field 'target'. The field 'target' has
     * the following description: the target (object) of the
     * association statement
     * 
     * @return the value of field 'Target'.
     */
    public StatementTarget getTarget(
    ) {
        return this._target;
    }

    /**
     * Overrides the java.lang.Object.hashCode method.
     * <p>
     * The following steps came from <b>Effective Java Programming
     * Language Guide</b> by Joshua Bloch, Chapter 3
     * 
     * @return a hash code value for the object.
     */
    public int hashCode(
    ) {
        int result = super.hashCode();

        long tmp;
        if (_associationID != null) {
           result = 37 * result + _associationID.hashCode();
        }
        if (_localID != null) {
           result = 37 * result + _localID.hashCode();
        }
        if (_derivation != null) {
           result = 37 * result + _derivation.hashCode();
        }
        if (_subject != null) {
           result = 37 * result + _subject.hashCode();
        }
        if (_predicate != null) {
           result = 37 * result + _predicate.hashCode();
        }
        if (_target != null) {
           result = 37 * result + _target.hashCode();
        }
        if (_assertedBy != null) {
           result = 37 * result + _assertedBy.hashCode();
        }

        return result;
    }

    /**
     * Method isValid.
     * 
     * @return true if this object is valid according to the schema
     */

    /**
     * 
     * 
     * @param out
     * @throws org.exolab.castor.xml.MarshalException if object is
     * null or if any SAXException is thrown during marshaling
     * @throws org.exolab.castor.xml.ValidationException if this
     * object is an invalid instance according to the schema
     */

    /**
     * 
     * 
     * @param handler
     * @throws java.io.IOException if an IOException occurs during
     * marshaling
     * @throws org.exolab.castor.xml.ValidationException if this
     * object is an invalid instance according to the schema
     * @throws org.exolab.castor.xml.MarshalException if object is
     * null or if any SAXException is thrown during marshaling
     */

    /**
     * Sets the value of field 'assertedBy'. The field 'assertedBy'
     * has the following description: the code system version that
     * is making this assertion
     * 
     * @param assertedBy the value of field 'assertedBy'.
     */
    public void setAssertedBy(
            final CodeSystemVersionReference assertedBy) {
        this._assertedBy = assertedBy;
    }

    /**
     * Sets the value of field 'associationID'. The field
     * 'associationID' has the following description: the unique
     * identifier of the association instance. While the update
     * mechanism of the CTS2 specifications requires that all
     * Changeable elements have unique identifiers, the rules
     *  and mechanism for assigning unique identifiers to
     * statements and associations are non-trivial. At the moment,
     * the CTS2 specification remains silent when it comes to
     * arriving at how this identifier is
     *  generated except to note that, if two service
     * implementations do not generate the same unique identifier
     * for the same assertion, then the prevImage element in
     * Changeable becomes the only way to
     *  identify which Association instance is being updated or
     * deleted.
     * 
     * @param associationID the value of field 'associationID'.
     */
    public void setAssociationID(
            final String associationID) {
        this._associationID = associationID;
    }

    /**
     * Sets the value of field 'derivation'. The field 'derivation'
     * has the following description: how this association was
     * derived. ASSERTED takes precedence over DERIVED , meaning
     * that an assertion that is both asserted and derived is
     * marked as asserted.
     * 
     * @param derivation the value of field 'derivation'.
     */
    public void setDerivation(
            final AssociationDerivation derivation) {
        this._derivation = derivation;
    }

    /**
     * Sets the value of field 'localID'. The field 'localID' has
     * the following description: the local identifier of the
     * association instance. If externalStatementID is present, it
     * will be used
     *  for the localId. If not, the localID will be generated by
     * the service.
     * 
     * @param localID the value of field 'localID'.
     */
    public void setLocalID(
            final String localID) {
        this._localID = localID;
    }

    /**
     * Sets the value of field 'predicate'. The field 'predicate'
     * has the following description: the predicate of the
     * association statement
     * 
     * @param predicate the value of field 'predicate'.
     */
    public void setPredicate(
            final PredicateReference predicate) {
        this._predicate = predicate;
    }

    /**
     * Sets the value of field 'subject'. The field 'subject' has
     * the following description: the subject of the association
     * statement
     * 
     * @param subject the value of field 'subject'.
     */
    public void setSubject(
            final URIAndEntityName subject) {
        this._subject = subject;
    }

    /**
     * Sets the value of field 'target'. The field 'target' has the
     * following description: the target (object) of the
     * association statement
     * 
     * @param target the value of field 'target'.
     */
    public void setTarget(
            final StatementTarget target) {
        this._target = target;
    }

    /**
     * Method unmarshalAssociationDirectoryEntry.
     * 
     * @param reader
     * @throws org.exolab.castor.xml.MarshalException if object is
     * null or if any SAXException is thrown during marshaling
     * @throws org.exolab.castor.xml.ValidationException if this
     * object is an invalid instance according to the schema
     * @return the unmarshaled
     * edu.mayo.cts2.framework.model.association.AssociationDirectoryEntry
     */

    /**
     * 
     * 
     * @throws org.exolab.castor.xml.ValidationException if this
     * object is an invalid instance according to the schema
     */

}
